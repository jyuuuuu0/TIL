# 동기와 비동기 차이

## 동기

동기란 프로그래밍에서 작업이 순차적으로 진행되는 것을 의미한다.

즉, 한 작업이 시작되면 해당 작업이 완료될 때까지 다른 작업들이 기다려야 한다.

동기 방식은 호출한 함수 또는 작업이 반환될 때까지 대기하는 동안 실행 흐름이 차단되는 특징이 있다.

이 때문에 UI가 멈춘 느낌이 들 수 있다.

동기 방식은 일반적으로 간단하고 직관적인 코드를 작성하기 쉽다.

하지만 여러 작업이 동시에 실행되어야 하는 경우, 각 작업의 완료를 기다리는 동안 시간이 소요되어 전체 프로세스의 성능이 저하 될 수 있다.

또한 한 작업이 지연되면 다른 작업들도 모두 지연되는 문제가 발생할 수 있다.

## 비동기

비동기는 프로그래밍에서 작업을 시작한 뒤, 완료를 기다리지 않고 다음 코드를 실행할 수 있는 방식이다.

즉, 비동기 방식은 작업이 시작되면 해당 작업이 완료될 때까지 기다리지 않고 코드를 실행할 수 있다.

비동기 방식은 주로 I/O 작업이나 네트워크 요청과 같이 시간이 오래 걸리는 작업에 유용하다.

이러한 작업을 비동기적으로 처리하면, 프로그램은 작업이 완료되기를 기다리는 동안 다른 작업을 처리할 수 있으므로 전체적인 성능이 향상된다.

비동기 방식은 콜백(callback), 프로미스(promise), async/await 등의 메커니즘을 통해 구현될 수 있다.

### 콜백(callback)

콜백은 다른 함수에 전달되어, 그 함수의 작업이 끝난 뒤 호출되는 함수이다.

즉, 직접 지금 실행 하는게 아닌 다른 함수가 대신 나중에 실행 시켜준다.

#### 그렇다면 콜백은 왜 필요한가?

```js
console.log("A");

setTimeout(() => {
  console.log("B");
}, 1000);

console.log("C");
```

출력:

```css
A
C
B
```

B가 마지막인 이유는 `setTimeout`은 지금 당장 실행되지 않고, 나중에 실행할 함수에 맡겨두기 때문이다.

이때 나중에 실행할 함수가 콜백이다.

#### 많이 보이는 콜백

1. 이벤트 콜백

```js
button.addEventListener("click", () => {
  console.log("버튼 클릭됨");
});
```

- 클릭이 언제 일어날지 모름.
- 그래서 클릭되면 실행할 함수를 미리 넘겨둔다.

2. 타이머 콜백

```js
setTimeout(() => {
  console.log("3초 뒤 실행");
}, 3000);
```

3. 배열 메서드 콜백

```js
[1, 2, 3].forEach((item) => {
  console.log(item);
});
```

- `forEach`가 내부에서 우리가 넘긴 함수를 각 요소마다 호출한다.

#### 콜백의 문제

```js
login(user, () => {
  getProfile(() => {
    getPosts(() => {
      console.log("모든 작업 완료");
    });
  });
});
```

##### 문제점

- 코드가 오른쪽으로 계속 깊어진다.
- 에러 처리가 힘들다
- 읽기 어렵다.

그래서 Promise -> async/await 가 나왔다.

콜백은 이벤트 처리와 간단한 비동기 작업 배열 메서드에 용이하고 복잡한 비동기 흐름에는 부적합하다.

### Promise

Promise란 지금은 결과가 없지만 나중에 성공 또는 실패를 알려주는 객체이다.

#### Promise 상태

promise의 상태 세 가지이다.
| 상태 | 의미 |
| --------- | ------ |
| pending | 기다리는 중 |
| fulfilled | 성공 |
| rejected | 실패 |

한 번 성공/실패 하면 다시 바뀌지 않는다.

#### 코드

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("데이터 도착!");
    // reject("에러 발생!");
  }, 2000);
});
```

- `resolve` -> 성공
- `reject` -> 실패

```js
promise
  .then((result) => {
    console.log(result);
  })
  .catch((error) => {
    console.log(error);
  });
```

성공하면 then, 실패하면 catch

#### Promise 체이닝

```js
fetchUser()
  .then((user) => {
    return fetchPosts(user.id);
  })
  .then((posts) => {
    console.log(posts);
  })
  .catch((err) => {
    console.error(err);
  });
```

##### 좋은 점

- 콜백처럼 안으로 들어가지 않는다.
- 위에서 아래로 읽힌다.

#### 실제 코드

```js
fetch("/api/user")
  .then((response) => response.json())
  .then((data) => {
    console.log(data);
  })
  .catch((error) => {
    console.error(error);
  });
```

- fetch 자체가 promise를 반환한다.

한 문장으로 정리하면

> Promise는 콜백 지옥을 피하고, 비동기 흐름을 직선으로 만들기 위한 도구이다.

### async/await

> Promise 기반 비동기 코드를 동기 코드처럼 읽히게 해주는 문법이다.

- 진짜로 전체가 멈추는게 아닌 해당 함수만 잠깐 멈춘 것처럼 보이게 한다.

#### async란?

> async는 이 함수는 비동기 결과를 promise로 돌려주는 함수다 라고 자바스크립트에게 알려주는 키워드이다.

```js
async function getData() {
  return "결과";
}
```

이 함수는 겉보기엔 문자열을 리턴하는 것처럼 보이지만 실제로는 Promise를 리턴한다.

자바스크립트 입장에서는 이 코드가 이렇게 동작한다.

```js
function getData() {
  return Promise.resolve("결과");
}
```

즉,

- return 값 → Promise.resolve(값)
- throw 에러 → Promise.reject(에러)

그러면 왜 async 함수에 then을 쓸 수 있을까?

```js
getData().then((result) => {
  console.log(result);
});
```

이게 가능한 이유는

> async 함수는 항상 promise를 반환하기 때문이다.

그래서:

- 일반 함수 → 결과를 바로 줌
- async 함수 → 결과를 Promise에 담아서 줌

#### await란?

> await는 promise가 끝날 때까지 그 promise의 결과가 나왔다고 가정하고 다음 줄을 실행하지 않게 해주는 문법이다.

```js
const result = await somePromise;
```

이 한 줄을 말로 풀면 이렇게 된다.

> “somePromise가 아직 안 끝났으면
> 이 함수 안에서는 다음 줄로 내려가지 말고,
> 끝난 다음에 그 결과 값을 result에 넣어라”

즉,

- Promise가 resolve되면
  → resolve 값이 result가 됨
- Promise가 reject되면
  → 에러가 발생함 (throw됨)

##### Promise를 그대로 쓰면

```js
const p = fetch("/api/user");
```

p는 결과가 아니고 그냥 "나중에 결과 줄게"라는 promise 객체이다.

##### await를 쓰면

```js
const user = await fetch("/api/user");
```

user은 promise가 끝난 뒤의 결과 즉, resolve된 값이다.

#### 코드

```js
async function run() {
  const data = await fetch("/api/user");
  console.log(data);
}
```

- fetch는 비동기
- await는 promise가 끝날 때까지 대기
- UI는 멈추지 않음

#### then -> async/await 변환

##### Promise 체이닝

```js
fetch("/api/user")
  .then((res) => res.json())
  .then((data) => {
    console.log(data);
  })
  .catch((err) => {
    console.error(err);
  });
```

##### async/await

```js
async function getUser() {
  try {
    const res = await fetch("/api/user");
    const data = await res.json();
    console.log(data);
  } catch (err) {
    console.error(err);
  }
}
```

#### 에러 처리 방식

```js
try {
  const data = await promise;
} catch (err) {
  console.error(err);
}
```

- try / catch는 await 중에 발생한 reject를 잡음

#### await는 왜 함수 안에서만 쓸 수 있는가

await는 잠깐 멈춤을 의미하는데 JS는 함수 단위로만 실행 흐름을 제어 가능 하다.

그래서 async 함수 안에서만 허용한다.
